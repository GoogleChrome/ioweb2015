<!--
Copyright 2016 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/google-apis/google-js-api.html">
<!-- <link rel="import" href="../bower_components/google-apis/google-client-api.html"> -->
<!-- <link rel="import" href="../bower_components/google-apis/google-client-loader.html"> -->

<!--
`<google-signin>` uses Google Sign-in 2.0 to authorize users using Google's
OAuth 2.0 flow. See https://developers.google.com/identity/sign-in/web/sign-in.

#### Example

    <google-signin load></google-signin>
-->
<!--
Fired when the signed in state of the user changes.

@event signin-change
@param {Object} detail
@param {Object} detail.signedIn True if the user is authenticated.
@param {Object} detail.user The current user.
@param {Object} detail.response The current user's token response.
-->
<!--
Fired when sign in fails for some reason.

@event signin-fail
@param {Object} detail
@param {Object} detail.error The reason for sign in failure.
-->
<dom-module id="google-signin">
  <template>
    <template is="dom-if" if="[[load]]">
      <google-js-api on-js-api-load="onLoadAuth"></google-js-api>
    </template>
  </template>
  <script>
    (function () {
      var AUTH_ENDPOINT = 'api/v1/auth';

      Polymer({
        is: 'google-signin',

        hostAttributes: {hidden: true},

        properties: {
          /**
           * A Google Developers client Id.
           */
          clientId: {
            type: String,
            value: null,
            notify: true
          },

          /**
           * If true, the JS client library is loaded and auth is initialized.
           */
          load: {
            type: Boolean,
            value: false
          },

          /**
           * A space-separated list of OAuth2 scopes.
           */
          scopes: {
            type: String,
            value: null
          },

          /**
           * If true, the is signed in.
           */
          signedIn: {
            type: Boolean,
            value: false,
            notify: true
          },

          /**
           * The logged in user.
           */
          user: {
            type: Object,
            value: null,
            notify: true
          }
        },

        created: function() {
          if (window.ENV === 'dev' || location.hostname === 'localhost') {
            this.cookiePolicy = 'single_host_origin';
          } else {
            this.cookiePolicy = location.protocol + '//' + location.host;
          }
          this.signinChangedHandler_ = this.signinChangedHandler.bind(this);
        },

        onLoadAuth: function(e, detail) {
          gapi.load('auth2', function () {
            // Init auth.
            this.auth2 = gapi.auth2.init({
              client_id: this.clientId,
              scope: this.scopes,
              fetch_basic_profile: true,
              cookie_policy: this.cookiePolicy
            });
            this.auth2.isSignedIn.listen(this.signinChangedHandler_);
          }.bind(this));
        },

        signIn: function() {
          if (!this.auth2 || this.auth2.isSignedIn.get()) {
            return;
          }
          // Sign the user in.
          // this.auth2.signIn().then(function() {
          // Sign in user + offline access for server calls.
          // TODO: check with server if user already has token.
          this.auth2.grantOfflineAccess({'redirect_uri': 'postmessage'}).then(function(resp) {
            // We have a one time code, but we're not signed in yet with a current
            // user and access token. Stash the one time for signinChangedHandler
            // to post it to the server.
            this.oneTimeCode = resp.code;
          }.bind(this), this.onSignInError);
        },

        signOut: function () {
          this.auth2.signOut().then(undefined, this.onSignInError.bind(this));
        },

        signinChangedHandler: function(signedIn) {
          this.signedIn = signedIn;
          this.currentUser = this.auth2.currentUser.get();
          var token = this.currentUser.getAuthResponse();
          if (this.signedIn) {
            var profile = this.currentUser.getBasicProfile();
            this.user = {
              id: profile.getId(),
              name: profile.getName(),
              picture: profile.getImageUrl() || 'images/schedule/profile_placeholder.png',
              email: profile.getEmail(),
              tokenResponse: token
            };
            if (this.oneTimeCode) {
              this.sendCodeToServer(this.oneTimeCode, function() {
                this.fire('signin-change', {
                  signedIn: true,
                  user: this.user
                });
              }.bind(this));
              this.oneTimeCode = null;
            } else {
              this.fire('signin-change', {signedIn: true, user: this.user});
            }
          } else {
            this.user = null;
            this.signedIn = false;
            this.fire('signin-change', {signedIn: false, user: null});
          }
        },

        sendCodeToServer: function (oneTimeCode, opt_callback) {
          var xhr = new XMLHttpRequest();
          xhr.open('POST', AUTH_ENDPOINT);
          var token = this.auth2.currentUser.get().getAuthResponse();
          xhr.setRequestHeader(
              'Authorization', 'Bearer ' + (token.id_token || token.access_token));
          xhr.setRequestHeader('Content-Type', 'application/json');
          xhr.onload = function (e) {
            if (e.target.status === 200) {
              opt_callback && opt_callback();
            } else {
              this.signOut();
              // One-time token could not be saved in backend. Log user out.
              // handle a special case where the server does not possess an offline token anymore
              // and so the whole auth flow should be retried again.
              if (e.target.status === 498) {
                // we could do this.auth2.disconnect().then(this.signIn.bind(this))
                // but chrome blocks the popup window. so, just let the user tap
                // on 'sign in' button again.
                this.auth2.disconnect();
              }
              this.fire('signin-fail', {
                error: 'Server-side auth failed with ' + e.target.status,
                oneTimeCodeFail: true
              });
            }
          }.bind(this);
          xhr.send(JSON.stringify({ code: oneTimeCode }));
        },

        onSignInError: function (error) {
          console.error(error);
        }
      });
    }());
  </script>
</dom-module>
